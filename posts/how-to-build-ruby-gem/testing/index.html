<!doctype html> <html lang=zh-CN> <head> <title>Teddy Ma's Homepage | </title> <meta content="IE=edge" http-equiv=X-UA-Compatible> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no" name=viewport> <meta name=author content="Teddy Ma"> <meta name=description content="Teddy Ma's Personal Website"> <meta name=keywords content="programming, software engineer, code"> <link rel=stylesheet href="https://www.songofcode.com/socss/assets/toolkit/styles/toolkit.css"/> <!--[if lt IE 9]><script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--> <script>
window['_fs_debug'] = false;
window['_fs_host'] = 'fullstory.com';
window['_fs_org'] = 'MP5K7';
window['_fs_namespace'] = 'FS';
(function(m,n,e,t,l,o,g,y){
    if (e in m) {if(m.console && m.console.log) { m.console.log('FullStory namespace conflict. Please set window["_fs_namespace"].');} return;}
    g=m[e]=function(a,b,s){g.q?g.q.push([a,b,s]):g._api(a,b,s);};g.q=[];
    o=n.createElement(t);o.async=1;o.crossOrigin='anonymous';o.src='https://'+_fs_host+'/s/fs.js';
    y=n.getElementsByTagName(t)[0];y.parentNode.insertBefore(o,y);
    g.identify=function(i,v,s){g(l,{uid:i},s);if(v)g(l,v,s)};g.setUserVars=function(v,s){g(l,v,s)};g.event=function(i,v,s){g('event',{n:i,p:v},s)};
    g.shutdown=function(){g("rec",!1)};g.restart=function(){g("rec",!0)};
    g.log = function(a,b) { g("log", [a,b]) };
    g.consent=function(a){g("consent",!arguments.length||a)};
    g.identifyAccount=function(i,v){o='account';v=v||{};v.acctId=i;g(o,v)};
    g.clearUserCookie=function(){};
})(window,document,window['_fs_namespace'],'script','user');
</script> <link href="/assets/stylesheets/highlightjs/a11y-light-3f5cde8e.css" rel=stylesheet /> </head> <body class="posts posts_how-to-build-ruby-gem posts_how-to-build-ruby-gem_testing posts_how-to-build-ruby-gem_testing_index typo"> <article> <h1>构建一个 Ruby Gem 第三章 配置 测试/调试 环境</h1> <p>一本没有测试相关内容的 Ruby 的书不是完整的。如果你对发布和贡献开源项目感兴趣的话，社区会更严肃的对待你的代码如果它们是被测试覆盖的并且测试通过的话。 <a href="https://en.wikipedia.org/wiki/Test-driven_development">测试驱动开发(TDD)</a> 是一种实战，在你写代码之前先写测试。实践 TDD 帮助我们只写必要的能让测试通过的代码。这也能减少过度工程的可能性(注意到这里有一个模式了吗?)</p> <p>在 Ruby 测试社区有两种观点。一种喜欢 <a href="https://github.com/seattlerb/minitest">Minitest</a> (Ruby标准库内置的), 另一个更喜欢 <a href="https://relishapp.com/rspec">Rspec</a>。我喜欢后者并且每天都使用 Rspec。 我发现它很适合我而且我喜欢用 DSL 来组织我的测试。</p> <h2>依赖</h2> <p>为了加入 Rspec，让我们打开 <code>mega_lotto.gemspec</code> 文件然后加入下面的依赖：</p> <pre class=src lang=ruby>
spec.add_development_dependency <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">rspec</span><span style="color:#710">&quot;</span></span>
</pre> <p>注意: 由于我们不想强制让 <code>rspec</code> 被我们的宿主应用加载，我们使用 <code>add_development_dependency</code> 方法，而不是 <code>add_dependency</code> 。</p> <p>现在, 让我们切换到终端，在我们的 gem 的根目录下运行：</p> <pre class=example>
$ bundle install
</pre> <p>这会安装在 gemspec 里列出的所有的依赖(包括 Rspec)。输出结果就像下面那样：</p> <pre class=example>
Fetching gem metadata from https://rubygems.org/.........
Fetching gem metadata from https://rubygems.org/..
Resolving dependencies...
Resolvingdependencies...
Using rake (10.1.0)
Using bundler (1.3.5)
Using diff-lcs (1.2.5)
Using mega_lotto (0.0.1) from source at . Using rspec-core (2.14.7)
Using rspec-expectations (2.14.4) Using rspec-mocks (2.14.4)
Using rspec (2.14.1)
Your bundle is complete!
Use `bundle show [gemname]` to see where a bundled gem is installed.
</pre> <p>不要过于在意版本号，它们会经常更变。正如你所看到的， <code>bundler</code> 安装了 <code>rake</code> ， <code>rspec</code> (由多个 gem 组成)，和我们的 gem, <code>mega_lotto</code> 。 为了完成 Rspec 的安装，在 gem 的根目录下运行下面的命令：</p> <pre class=example>
$ rspec --init
</pre> <p>输出的结果如下:</p> <pre class=example>
create   spec/spec_helper.rb
create   .rspec
</pre> <p>一个 <code>spec</code> 目录在我们的项目中被创建，并且里面有一个 <code>spec_helper.rb</code> 文件。</p> <p>我们需要在 <code>spec_helper</code> 中加点东西。因为我们想要测试我们的 gem 的代码，我们需要从 <code>spec_helper.rb</code> 中加载它: 在 <code>spec/spec_helper.rb</code> 文件的头部加上 =require &#8220;mega_lotto&#8221;= 这行。</p> <pre class=src lang=ruby>
require <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">mega_lotto</span><span style="color:#710">&quot;</span></span>
<span style="color:#777"># This file was generated by the `rspec --init` command. Conventionally, all</span>
<span style="color:#777"># specs live under a `spec` directory, which RSpec adds to the `$LOAD_PATH`.</span>
<span style="color:#777"># Require this file using `require &quot;spec_helper&quot;` to ensure that it is only</span>
<span style="color:#777"># loaded once.</span>
<span style="color:#777">#</span>
<span style="color:#777"># See http://rubydoc.info/gems/rspec-core/RSpec/Core/Configuration</span>
<span style="color:#036;font-weight:bold">RSpec</span>.configure <span style="color:#080;font-weight:bold">do</span> |config|
  config.treat_symbols_as_metadata_keys_with_true_values = <span style="color:#069">true</span>
  config.run_all_when_everything_filtered = <span style="color:#069">true</span>
  config.filter_run <span style="color:#A60">:focus</span>
  <span style="color:#777"># Run specs in random order to surface order dependencies. If you find an</span>
  <span style="color:#777"># order dependency and want to debug it, you can fix the order by providing</span>
  <span style="color:#777"># the seed, which is printed after each run.</span>
  <span style="color:#777"># --seed 1234</span>
  config.order = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">random</span><span style="color:#710">'</span></span>
<span style="color:#080;font-weight:bold">end</span>
</pre> <p>注意：不同版本的 <code>rspec</code> 在 <code>spec_helper.rb</code> 中生产的内容也可能不同。如果你使用了不同版本的 <code>rspec</code> ，你的 <code>spec_helper.rb</code> 文件可能看上去不一样。</p> <p>现在，我们可以在命令行运行 <code>rspec spec</code> 然后得到下面的信息：</p> <pre class=example>
No examples found.
Finished in 0.00007 seconds
0 examples, 0 failures
</pre> <p>注意： <code>rspec</code> 是用来运行 <code>rspec</code> 测试的命令，不内涵。它接受文件路径作为参数(文件或目录)来确定要执行哪个测试。这确保了我们的测试基础设施被正确的设置了。</p> <p>通常来说，=spec/= 目录(当使用 <code>rspec</code> 时我们的测试被安置的地方)，是我们的 gem 的 <code>lib/</code> 目录的镜像。 我们之后会看到这是如何工作的, 假如模块 <code>lib/meag_lotto/drawing.rb</code> 被加入到我们的 gem 中, <code>spec/mega_lotto/drawing_spec.rb</code> 将是相符的 spec 文件.</p> <p>正如我们上面看到的，gem 可以有依赖。有时候当你安装一个 gem 时，几个其他的 gem 也会被安装。这是因为被定义在 <code>gemspec</code> 里的依赖。 如果你以前在一个 rails 应用中使用 <code>unicorn</code> gem，你可能注意到安装 <code>unicorn</code> 导致 <code>gemfile.lock</code> 中多了几行。 这几行就是在 <code>unicorn</code> 的 <code>gemspec</code> 中定义的依赖。</p> <h2>Rake 任务</h2> <p>为了运行通过 <code>rspec spec/</code> 命令来执行我们的 specs，我们可以更新我们的 <code>Rakefile</code> 来包含一个 <code>spec</code> 任务并且设置为默认：</p> <pre class=src lang=ruby>
require <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">bundler/gem_tasks</span><span style="color:#710">&quot;</span></span>
require <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">rspec/core/rake_task</span><span style="color:#710">&quot;</span></span>
<span style="color:#036;font-weight:bold">RSpec</span>::<span style="color:#036;font-weight:bold">Core</span>::<span style="color:#036;font-weight:bold">RakeTask</span>.new(<span style="color:#A60">:spec</span>)

task <span style="color:#A60">:default</span> =&gt; <span style="color:#A60">:spec</span>
</pre> <p>现在我们可以使用我们的终端来运行 <code>rake</code> 来看看和上面一样的输出：</p> <pre class=src lang=sh>
$ rake
No examples found.
Finished in 0.00007 seconds
0 examples, 0 failures
</pre> <p>我们要加入的另一个任务是一个快捷键来进入一个终端会话。如果你熟悉 Rails，你应该知道 <code>rails c</code> 是一个很牛逼的工具。 我们可以给我们的 gem 类似的功能。如果我们的系统中有 Ruby，我们可以打开一个命令行使用 <code>irb</code> 命令来进入一个 Ruby 交互环境：</p> <pre class=src lang=sh>
$ irb
irb(main):001:0&gt; 2 + 2 =&gt; 4
irb(main):002:0&gt; exit
</pre> <p>非常好，只不过解释器没有加载任何 Ruby 标准库以外的东西。这对我们没什么帮助，但是幸运的是 <code>irb</code> 命令接受的一些参数可以帮我们一些忙：</p> <pre class=src lang=sh>
$ irb --help
Usage:  irb.rb [options] [programfile] [arguments]
  -f            Suppress read of ~/.irbrc
  -m            Bc mode (load mathn, fraction or matrix are available)
  -d                Set $DEBUG to true (same as `ruby -d')
  -r load-module    Same as `ruby -r'
  -I path           Specify $LOAD_PATH directory
  -U                Same as `ruby -U`
  -E enc            Same as `ruby -E`
  -w                Same as `ruby -w`
  -W[level=2]       Same as `ruby -W`
</pre> <p><code>-I</code> 参数允许我们加入一个特定的目录到 Ruby 的 load path。</p> <p>记得吗当我们讨论 <code>lib/mega_lotto</code> 目录时看到的 <code>mega_lotto.gemspec</code> 文件的头部</p> <pre class=src lang=ruby>
...
lib = <span style="color:#036;font-weight:bold">File</span>.expand_path(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">../lib</span><span style="color:#710">'</span></span>, ___FILE___)
<span style="color:#d70">$LOAD_PATH</span>.unshift(lib) <span style="color:#080;font-weight:bold">unless</span> <span style="color:#d70">$LOAD_PATH</span>.include?(lib)
...
</pre> <p>当 bundler 加载我们的 gem 时，它也加载了 <code>lib/</code> 目录, 所以我们可以使用我们的库。</p> <p>所以通过使用 <code>-I</code> 我们可以指定 <code>lib/</code> 目录来保证 <code>irb</code> 可以使用我们的代码。</p> <p>另外，在通常状况下，我们看到 <code>irb</code> 不会加载 Ruby 标准库以外的库。所以即使我们加上了我们的 <code>lib/</code> 目录到 load path， 我们不得不指定调用 <code>require &quot;mega_lotto&quot;= 来加载我们的代码当会话开始时。 所以，选项 =-r</code> 被我们使用了。它允许我们当会话开始时去加载一个指定库，所以我们不用手动去做这件事了。</p> <p>把这些参数组合起来我们就得到了一个牛逼的工具来检验我们的 gem 的代码：</p> <pre class=src lang=sh>
$ irb -r mega_lotto -I ./lib
irb(main):001&gt; MegaLotto
=&gt; MegaLotto
</pre> <p>我们可以看到 <code>MegaLotto</code> 模块在使用合适的参数的irb会话中被使用了。</p> <p>更进一步，我们可以把这行命令加入到我们的 =Rakefile=，这样我们就能更容易的调用了。</p> <pre class=src lang=ruby>
require <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">bundler/gem_tasks</span><span style="color:#710">&quot;</span></span>
require <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">rspec/core/rake_task</span><span style="color:#710">&quot;</span></span>

<span style="color:#036;font-weight:bold">RSpec</span>::<span style="color:#036;font-weight:bold">Core</span>::<span style="color:#036;font-weight:bold">RakeTask</span>.new(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">spec</span><span style="color:#710">&quot;</span></span>)

task <span style="color:#A60">:default</span>  =&gt; <span style="color:#A60">:spec</span>

task <span style="color:#A60">:console</span> <span style="color:#080;font-weight:bold">do</span>
  exec <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">irb -r mega_lotto -I ./lib</span><span style="color:#710">&quot;</span></span>
<span style="color:#080;font-weight:bold">end</span>
</pre> <p>这让我们可以快捷的从命令行运行 <code>rake console</code></p> <pre class=src lang=sh>
$ rake console

irb(main):001:0&gt; MegaLotto
=&gt; MegaLotto
</pre> <h2>调试</h2> <p>无论我们怎么不愿意承认，我们没有写出完美的代码。Ruby 有很多调试工具，但是 <code>pry</code> 是我的选择。 既然 <code>mega_lotto.gemspec</code> 负责根据环境加载依赖，我们可以加入 <code>pry</code> 到开发列表中：</p> <pre class=src lang=ruby>
...
spec.add_development_dependency <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">bundler</span><span style="color:#710">&quot;</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">~&gt; 1.3</span><span style="color:#710">&quot;</span></span>
spec.add_development_dependency <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">rake</span><span style="color:#710">&quot;</span></span>
spec.add_development_dependency <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">rspec</span><span style="color:#710">&quot;</span></span>
spec.add_development_dependency <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">pry</span><span style="color:#710">&quot;</span></span>
</pre> <p>运行 <code>bundle install</code> 我们可以看到 <code>pry</code> gem 被列出来了：</p> <pre class=example>
Resolving dependencies...
Using rake (10.1.0)
Using bundler (1.3.5)
Using coderay (1.1.0)
Using diff-lcs (1.2.5)
Using mega_lotto (0.0.2) from source at . Using method_source (0.8.2)
Using slop (3.4.7)
Using pry (0.9.12.3)
Using rspec-core (2.14.7)
Using rspec-expectations (2.14.4)
Using rspec-mocks (2.14.4)
Using rspec (2.14.1)
Your bundle is complete!
Use `bundle show [gemname]` to see where a bundled gem is installed.
</pre> <p>注意： <code>pry</code> gem 已经安装在我的系统中了，所以在输出中有 &#8220;Using pry (&#8230;)&#8221;. 如果 <code>pry</code> 之前没有被安装，输出应该是 &#8220;Installing pry(&#8230;)&#8221;</p> <p>现在 <code>pry</code> 安装好了，我们需要去加载它。正如前面所提到的， <code>lib/mega_lotto.rb</code> 文件是加载其他代码到 gem 里的主要入口。</p> <p>通常情况下，我们可以在头部引入 <code>pry</code> 。然而，记住我们只在开发环境下使用 <code>pry</code> 这意味着当我们的 gem 被宿主应用加载时，它会尝试去加载 <code>pry</code> ，有可能会因为没有 <code>pry</code> 而抛出 Ruby <code>LoadError</code> 异常。</p> <p>知道了这个可能发生的异常，我们可以使用 rescue 然后不做任何处理：</p> <pre class=src lang=ruby>
<span style="color:#777"># lib/mega_lotto.rb</span>

require <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">mega_lotto/version</span><span style="color:#710">&quot;</span></span>

<span style="color:#080;font-weight:bold">begin</span>
  require <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">pry</span><span style="color:#710">&quot;</span></span>
<span style="color:#080;font-weight:bold">rescue</span> <span style="color:#036;font-weight:bold">LoadError</span>
<span style="color:#080;font-weight:bold">end</span>

<span style="color:#080;font-weight:bold">module</span> <span style="color:#B06;font-weight:bold">MegaLotto</span>
<span style="color:#080;font-weight:bold">end</span>
</pre> <p>注意我们是如何使用 <code>rescue LoadError</code> 代码块来捕获异常的，但是现在我们不做任何处理。 如果不这样做， <code>LoadError</code> 异常就会被抛出然后我们的代码就不能被执行下去了。</p> <p>一旦 <code>pry</code> 被加载，我们就可以使用 <code>binding.pry</code> 方法来停止代码在那个点上并且开启一个 REPL 会话来调试。让我们在模块里加入：</p> <pre class=src lang=ruby>
require <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">mega_lotto/version</span><span style="color:#710">&quot;</span></span>

<span style="color:#080;font-weight:bold">begin</span>
  require <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">pry</span><span style="color:#710">&quot;</span></span>
<span style="color:#080;font-weight:bold">rescue</span> <span style="color:#036;font-weight:bold">LoadError</span>
<span style="color:#080;font-weight:bold">end</span>

<span style="color:#080;font-weight:bold">module</span> <span style="color:#B06;font-weight:bold">MegaLotto</span>
  binding.pry
<span style="color:#080;font-weight:bold">end</span>
</pre> <pre class=src lang=sh>
$ rake console
Frame number: 0/7
From: /Users/bhilkert/Dropbox/code/mega_lotto/lib/mega_lotto.rb @ line 12 :
     7:   require &quot;pry&quot;
     8: rescue LoadError
     9: end
     10:
     11: module MegaLotto
     =&gt; 12: binding.pry
     13: end
[1] pry(MegaLotto)&gt;
</pre> <p>完美！</p> <p>注意: 使用 <code>exit</code> 命令来退出 <code>pry</code> 会话。</p> <p>我们就不继续下去了，我们会从入口文件移除 <code>binding.pry</code> ，但是保留加载的代码这样我们以后还可以使用：</p> <pre class=src lang=ruby>
require <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">mega_lotto/version</span><span style="color:#710">&quot;</span></span>

<span style="color:#080;font-weight:bold">begin</span>
  require <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">pry</span><span style="color:#710">&quot;</span></span>
<span style="color:#080;font-weight:bold">rescue</span> <span style="color:#036;font-weight:bold">LoadError</span>
<span style="color:#080;font-weight:bold">end</span>

<span style="color:#080;font-weight:bold">module</span> <span style="color:#B06;font-weight:bold">MegaLotto</span>
<span style="color:#080;font-weight:bold">end</span>
</pre> <p>使用 <code>pry</code> 的详细内容不是本书的范围。这是一个牛逼的 gem 并且值得去探索如果你经常使用 Ruby。</p> <p>我们就到此为止了，因为我们的测试框架和调试工具都已经被正确的安装和配置了。</p> <h2>总结</h2> <p>我们在本章花费了时间来配置很多工具。它们并不都是必要的，但是在我的开发过程中我发现了它们的价值。 一旦你多试几次这个过程，就只需要花上几分钟就能完成。有了这些工具能帮助你解决一些很麻烦的 bug。</p> <p>如果你更喜欢 <code>minitest</code> 而不是 <code>rspec</code> ，配置起来会容易些因为 <code>minitest</code> 已经内置在 Ruby 标准库中了，所以不需要额外的 gem。</p> <p>最后，gem 的依赖会很快的变得复杂。如果一个依赖的定义没有被维护，就可能给你留下很多 bug 和坑。 当然，依赖是有价值的，没有理由去复制功能如果已经有了可靠的解决方案。只要知道，随着你增加依赖，你的 gem 的复杂度就会上升。</p> <p>在下一章，我们会使用测试驱动的方式来研究和探索 Ruby 的命名空间是如何管理 gem 的文件结构的。</p> </article> <script src="/assets/javascripts/all-70879c36.js"></script> <script src="/assets/javascripts/highlight-e7667caa.js"></script> <script>hljs.initHighlightingOnLoad()</script> <div id=github-comments></div> <script src="/assets/javascripts/comment-ddc93c2f.js" id=github-comment data-ssl=true data-theme=green data-username=teddy-ma data-repo="teddy-ma.github.io" data-page-id="posts/how-to-build-ruby-gem/testing"></script> </body> </html>