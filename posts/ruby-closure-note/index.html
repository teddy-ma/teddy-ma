<!doctype html> <html lang=zh-CN> <head> <title>Teddy Ma's Homepage | </title> <meta content="IE=edge" http-equiv=X-UA-Compatible> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no" name=viewport> <meta name=author content="Teddy Ma"> <meta name=description content="Teddy Ma's Personal Website"> <meta name=keywords content="programming, software engineer, code"> <link rel=stylesheet href="https://www.songofcode.com/socss/assets/toolkit/styles/toolkit.css"/> <!--[if lt IE 9]><script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--> <script>
window['_fs_debug'] = false;
window['_fs_host'] = 'fullstory.com';
window['_fs_org'] = 'MP5K7';
window['_fs_namespace'] = 'FS';
(function(m,n,e,t,l,o,g,y){
    if (e in m) {if(m.console && m.console.log) { m.console.log('FullStory namespace conflict. Please set window["_fs_namespace"].');} return;}
    g=m[e]=function(a,b,s){g.q?g.q.push([a,b,s]):g._api(a,b,s);};g.q=[];
    o=n.createElement(t);o.async=1;o.crossOrigin='anonymous';o.src='https://'+_fs_host+'/s/fs.js';
    y=n.getElementsByTagName(t)[0];y.parentNode.insertBefore(o,y);
    g.identify=function(i,v,s){g(l,{uid:i},s);if(v)g(l,v,s)};g.setUserVars=function(v,s){g(l,v,s)};g.event=function(i,v,s){g('event',{n:i,p:v},s)};
    g.shutdown=function(){g("rec",!1)};g.restart=function(){g("rec",!0)};
    g.log = function(a,b) { g("log", [a,b]) };
    g.consent=function(a){g("consent",!arguments.length||a)};
    g.identifyAccount=function(i,v){o='account';v=v||{};v.acctId=i;g(o,v)};
    g.clearUserCookie=function(){};
})(window,document,window['_fs_namespace'],'script','user');
</script> <link href="/assets/stylesheets/highlightjs/a11y-light-3f5cde8e.css" rel=stylesheet /> </head> <body class="posts posts_ruby-closure-note posts_ruby-closure-note_index typo"> <article> <h1>Ruby Closure 读书笔记</h1> <p>Ruby 是一门虽然很 OO (不像 Java 还有基本类型，Ruby 中哪怕是数字也是对象) 但是也很 FP (支持 lambda curry) 的语言。</p> <p>而 Ruby 的 Closure 是一个非常牛逼的特性，想要学习它需要一定的 FP 和元编程的知识储备。</p> <p>让我们直接开始吧，先来看一下下面这个计数器的例子：</p> <pre class=src lang=ruby>
<span style="color:#080;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Counter</span>

  <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">initialize</span>
    <span style="color:#33B">@x</span> = <span style="color:#00D">0</span>
  <span style="color:#080;font-weight:bold">end</span>

  <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">get_x</span>
    <span style="color:#33B">@x</span>
  <span style="color:#080;font-weight:bold">end</span>

  <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">incr</span>
    <span style="color:#33B">@x</span> += <span style="color:#00D">1</span>
  <span style="color:#080;font-weight:bold">end</span>

  <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">decr</span>
    <span style="color:#33B">@x</span> -= <span style="color:#00D">1</span>
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>
</pre> <p>下面是对应的 lambda 方式的实现，通过这个例子的对比，我想你对 Lambda 应该有一个最基本的认识了。</p> <pre class=src lang=ruby>
<span style="color:#036;font-weight:bold">Counter</span> = lambda <span style="color:#080;font-weight:bold">do</span>
  x = <span style="color:#00D">0</span>
  get_x = lambda { x }
  incr = lambda { x += <span style="color:#00D">1</span> }
  decr = lambda { x += <span style="color:#00D">1</span> }

  { <span style="color:#606">get_x</span>: get_x, <span style="color:#606">incr</span>: incr, <span style="color:#606">decr</span>: decr }
<span style="color:#080;font-weight:bold">end</span>
</pre> <p>当然这个例子并不能发挥 lambda 的优势，这这种情况明显使用 Class 是更好的方案，这里只作为演示。</p> <p>下面再来看看回调函数的情况，这个例子我相信只要是写过 JavasScript 的同学都很熟悉了。</p> <pre class=src lang=ruby>
require <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">ostruct</span><span style="color:#710">'</span></span>
<span style="color:#080;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Notifier</span>
  attr_reader <span style="color:#A60">:generator</span>, <span style="color:#A60">:callbacks</span>

  <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">initialize</span>(generator, callbacks)
    <span style="color:#33B">@generator</span> = generator
    <span style="color:#33B">@callbacks</span> = callbacks
  <span style="color:#080;font-weight:bold">end</span>

  <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">run</span>
    result = generator.run
    <span style="color:#080;font-weight:bold">if</span> result
      callbacks.fetch(<span style="color:#A60">:on_success</span>).call(result)
    <span style="color:#080;font-weight:bold">else</span>
      callbacks.fetch(<span style="color:#A60">:on_failed</span>).call
    <span style="color:#080;font-weight:bold">end</span>
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>

<span style="color:#080;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Generator</span>
  attr_reader <span style="color:#A60">:report</span>

  <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">initialize</span>(report)
    <span style="color:#33B">@report</span> = report
  <span style="color:#080;font-weight:bold">end</span>

  <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">run</span>
    report.to_csv
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>

good_report = <span style="color:#036;font-weight:bold">OpenStruct</span>.new(<span style="color:#606">to_csv</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">59.00,Great Success</span><span style="color:#710">&quot;</span></span>)
bad_report = <span style="color:#036;font-weight:bold">OpenStruct</span>.new(<span style="color:#606">to_csv</span>: <span style="color:#069">nil</span>)

n = <span style="color:#036;font-weight:bold">Notifier</span>.new(
  <span style="color:#036;font-weight:bold">Generator</span>.new(good_report),
  <span style="color:#606">on_success</span>: lambda { |r| puts <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Send </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">#{</span>r<span style="font-weight:bold;color:#666">}</span></span><span style="color:#D20"> to boss</span><span style="color:#710">&quot;</span></span> },
  <span style="color:#606">on_failed</span>: lambda { puts <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Send to me</span><span style="color:#710">&quot;</span></span> }
)

n.run
</pre> <p>使用 JavaScript 来处理异步请求时肯定也会用到这样类似 on_succes, on_failed 的写法。</p> <p>这里展示的是使用 lambda 的实现方式。</p> <p>下面的例子需要一定的 FP 知识，如果看过《The Little Schemer》的话就很容易理解了。</p> <p>reduce 是一个 FP 中很常见（应该说是必备）的方法，在 Ruby 中也有，用法如下：</p> <pre class=src lang=ruby>
[<span style="color:#00D">1</span>,<span style="color:#00D">2</span>,<span style="color:#00D">3</span>,<span style="color:#00D">4</span>,<span style="color:#00D">5</span>].reduce(<span style="color:#00D">10</span>) { |acc, x| p <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">#{</span>acc<span style="font-weight:bold;color:#666">}</span></span><span style="color:#D20">, </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">#{</span>x<span style="font-weight:bold;color:#666">}</span></span><span style="color:#710">&quot;</span></span>; acc + x }
<span style="color:#777"># &quot;10, 1&quot;</span>
<span style="color:#777"># &quot;11, 2&quot;</span>
<span style="color:#777"># &quot;13, 3&quot;</span>
<span style="color:#777"># &quot;16, 4&quot;</span>
<span style="color:#777"># &quot;20, 5&quot;</span>
</pre> <p>下面我们要用 lambda 实现这个 reduce 方法：</p> <pre class=src lang=ruby>

adder = lambda <span style="color:#080;font-weight:bold">do</span> |acc, arr|
  <span style="color:#080;font-weight:bold">if</span> arr.empty?
    acc
  <span style="color:#080;font-weight:bold">else</span>
    adder.call(acc + arr.first, arr.drop(<span style="color:#00D">1</span>))
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>

puts adder.call(<span style="color:#00D">10</span>, [<span style="color:#00D">1</span>,<span style="color:#00D">2</span>,<span style="color:#00D">3</span>])

</pre> <p>这样很好，但是还不够灵活，因为上面的代码只能实现最简单的相加。</p> <p>我们要把一个 lambda 当作参数传入，这样就能支持更多的操作了：</p> <pre class=src lang=ruby>
reducer = lambda <span style="color:#080;font-weight:bold">do</span> |acc, arr, binary_function|
  <span style="color:#080;font-weight:bold">if</span> arr.empty?
    acc
  <span style="color:#080;font-weight:bold">else</span>
    reducer.call(
      binary_function.call(acc, arr.first),
      arr.drop(<span style="color:#00D">1</span>),
      binary_function
    )
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>
puts reducer.call(<span style="color:#00D">2</span>, [<span style="color:#00D">2</span>,<span style="color:#00D">3</span>,<span style="color:#00D">4</span>], lambda {|a, b| a * b}) <span style="color:#777"># =&gt; 48</span>
</pre> <p>这样一来，改成应用乘法也很容易了。</p> <p>不过这样的写法，在 else 中还要每次都调用 binary_function, 有点不优雅，可以改成下面这样：</p> <pre class=src lang=ruby>
reducer = lambda <span style="color:#080;font-weight:bold">do</span> |acc, arr, binary_function|
  reducer_aux = lambda <span style="color:#080;font-weight:bold">do</span> |acc, arr|
    <span style="color:#080;font-weight:bold">if</span> arr.empty?
      acc
    <span style="color:#080;font-weight:bold">else</span>
      reducer_aux.call(
        binary_function.call(acc, arr.first),
        arr.drop(<span style="color:#00D">1</span>)
      )
    <span style="color:#080;font-weight:bold">end</span>
  <span style="color:#080;font-weight:bold">end</span>

  reducer_aux.call(acc, arr)
<span style="color:#080;font-weight:bold">end</span>

puts reducer.call(<span style="color:#00D">2</span>, [<span style="color:#00D">2</span>,<span style="color:#00D">3</span>,<span style="color:#00D">4</span>], lambda {|a, b| a * b}) <span style="color:#777"># =&gt; 48</span>
</pre> <p>这个改动就是在 lambda 内部再创建了一个 lambda, 但是只接收 acc, arr 两个参数，在最后再去执行这个内部的 lambda.</p> <p>这个重构很好的说明了 lambda 的灵活性。</p> <p>下面再说说 Blocks, BLock 可以作为参数被方法接收，并在适当的时候被执行。</p> <p>直接看例子：</p> <pre class=src lang=ruby>
<span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">do_it</span>
  <span style="color:#080;font-weight:bold">yield</span>
<span style="color:#080;font-weight:bold">end</span>

do_it {puts <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">I'm doing it</span><span style="color:#710">&quot;</span></span>}

do_it { [<span style="color:#00D">1</span>,<span style="color:#00D">2</span>,<span style="color:#00D">3</span>] &lt;&lt; <span style="color:#00D">4</span>} <span style="color:#777"># =&gt; [1,2,3,4]</span>

<span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">do_it</span>(x,y)
  <span style="color:#080;font-weight:bold">yield</span>(x, y)
<span style="color:#080;font-weight:bold">end</span>

do_it(<span style="color:#00D">2</span>, <span style="color:#00D">3</span>) { |x, y| x + y }

</pre> <p>刚才说的适当的时候，就是方法中 yield 的时候，一旦看到 yile 就意味着传入的 block 要被执行了。</p> <p>现在我们来实现一下 each 方法：</p> <pre class=src lang=ruby>
<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">%w(</span><span style="color:#D20">look ma no for loops</span><span style="color:#710">)</span></span>.each <span style="color:#080;font-weight:bold">do</span> |x|
  puts x
<span style="color:#080;font-weight:bold">end</span>
</pre> <p>each 方法接收一个 block, 并且依次对每个元素执行 block 中的代码。</p> <p>下面是我们的实现：</p> <pre class=src lang=ruby>
<span style="color:#080;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Array</span>
  <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">each</span>
    x=<span style="color:#00D">0</span>
    <span style="color:#080;font-weight:bold">while</span> x &lt; <span style="color:#069">self</span>.length
      <span style="color:#080;font-weight:bold">yield</span> <span style="color:#069">self</span>[x]
      x += <span style="color:#00D">1</span>
    <span style="color:#080;font-weight:bold">end</span>
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>
</pre> <p>是不是很容易，再试试 times 的实现把：</p> <pre class=src lang=ruby>
<span style="color:#080;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Fixnum</span>
  <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">times</span>
    x=<span style="color:#00D">0</span>
    <span style="color:#080;font-weight:bold">while</span> x &lt; <span style="color:#069">self</span>
      x += <span style="color:#00D">1</span>
      <span style="color:#080;font-weight:bold">yield</span>
    <span style="color:#080;font-weight:bold">end</span>
    <span style="color:#069">self</span>
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>

<span style="color:#00D">3</span>.times { puts <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">D'oh!</span><span style="color:#710">&quot;</span></span> }
</pre> <p>Blocks 除了上面的枚举以外，还有一个常见的使用场景是管理资源。</p> <p>比如我们要打开一个文件输入一些内容：</p> <pre class=src lang=ruby>
f = <span style="color:#036;font-weight:bold">File</span>.open(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Leo Tolstoy - War and Peace.txt</span><span style="color:#710">'</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">w</span><span style="color:#710">'</span></span>)
f &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Well, Prince, so Genoa and Lucca</span><span style="color:#710">&quot;</span></span>
f &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20"> are now just family estates of the Buonapartes.</span><span style="color:#710">&quot;</span></span>
f.close
</pre> <p>这样的写法，如果忘了写 f.close 的话那可能会有很大的问题，当然为了解决这个问题，有很多解决方案。</p> <p>比如用一个方法包装起来，或者使用模板模式。这里我们要使用的当然是 block 了。</p> <pre class=src lang=ruby>
<span style="color:#036;font-weight:bold">File</span>.open(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">Leo Tolstoy - War and Peace.txt</span><span style="color:#710">'</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">w</span><span style="color:#710">'</span></span>) <span style="color:#080;font-weight:bold">do</span> |f|
  f &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Well, Prince, so Genoa and Lucca</span><span style="color:#710">&quot;</span></span>
  f &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20"> are now just family estates of the Buonapartes.</span><span style="color:#710">&quot;</span></span>
<span style="color:#080;font-weight:bold">end</span>
</pre> <p>这样的写法就很优雅了，不需要手动编写 file 的 close 语句了，下面我们来自己实现这个功能：</p> <pre class=src lang=ruby>
<span style="color:#080;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">File</span>
  <span style="color:#080;font-weight:bold">def</span> <span style="color:#069">self</span>.<span style="color:#06B;font-weight:bold">open</span>(name, mode)
    file = new(name, mode)
    <span style="color:#080;font-weight:bold">return</span> file <span style="color:#080;font-weight:bold">unless</span> block_given?
    <span style="color:#080;font-weight:bold">yield</span>(file)
  <span style="color:#080;font-weight:bold">ensure</span>
    file.close
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>

<span style="color:#036;font-weight:bold">File</span>.open(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">file_open.rb</span><span style="color:#710">&quot;</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">r</span><span style="color:#710">&quot;</span></span>) <span style="color:#080;font-weight:bold">do</span> |f|
  puts f.path
  puts f.ctime
  puts f.size
<span style="color:#080;font-weight:bold">end</span>

</pre> <p>可以看到， block_given? 这个方法可以判断有没有 block 被传入，如果没有，就执行普通的 new 方法创建一个 File 对象。 这就是上面第一种写法，否则就执行 yield, 并且在最后执行 close 方法（使用 ensure 确保一定会关闭文件）。</p> <p>之后是最后一个常见模式，优雅的对象初始化。</p> <p>对于对象初始化，一般都是定义在 initialize 方法中的，参数可以随意设置。但是当碰到需要大量参数才能初始化时，就不够优雅。</p> <p>比如我们有一个 Twiiter 的客户端，需要一些配置才能初始化：</p> <pre class=src lang=ruby>
client = <span style="color:#036;font-weight:bold">Twitter</span>::<span style="color:#036;font-weight:bold">REST</span>::<span style="color:#036;font-weight:bold">Client</span>.new(
  {
    <span style="color:#606">consumer_key</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">aaa</span><span style="color:#710">&quot;</span></span>
    <span style="color:#606">consumer_secret</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">bbb</span><span style="color:#710">&quot;</span></span>
    <span style="color:#606">access_token</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">ccc</span><span style="color:#710">&quot;</span></span>
    <span style="color:#606">access_token_secret</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">ddd</span><span style="color:#710">&quot;</span></span>
  }
)
</pre> <p>这样写也不差，不过如果可以像下面的写法那样岂不是更好吗</p> <pre class=src lang=ruby>
client = <span style="color:#036;font-weight:bold">Twitter</span>::<span style="color:#036;font-weight:bold">REST</span>::<span style="color:#036;font-weight:bold">Client</span>.new <span style="color:#080;font-weight:bold">do</span> |config|
  config.consumer_key = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">aaa</span><span style="color:#710">&quot;</span></span>
  config.consumer_secret = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">bbb</span><span style="color:#710">&quot;</span></span>
  config.access_token = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">ccc</span><span style="color:#710">&quot;</span></span>
  config.access_token_secret = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">ddd</span><span style="color:#710">&quot;</span></span>
<span style="color:#080;font-weight:bold">end</span>
</pre> <p>如果你觉得这个例子没说服力，那想想 Rails 的 routes 配置吧。</p> <pre class=src lang=ruby>
routes = <span style="color:#036;font-weight:bold">Router</span>.new <span style="color:#080;font-weight:bold">do</span> |r|
  r.match <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">/about</span><span style="color:#710">'</span></span> =&gt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">home#about</span><span style="color:#710">'</span></span>
  r.match <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">/users</span><span style="color:#710">'</span></span> =&gt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">users#index</span><span style="color:#710">'</span></span>
  <span style="color:#777"># .....</span>
<span style="color:#080;font-weight:bold">end</span>

</pre> <p>这样路由配置可能多达上百行，还使用基本的 new 的写法肯定不行了。所以接下来我们来试着实现一下 block 形式的对象初始化吧。</p> <pre class=src lang=ruby>
<span style="color:#080;font-weight:bold">module</span> <span style="color:#B06;font-weight:bold">Twitter</span>
  <span style="color:#080;font-weight:bold">module</span> <span style="color:#B06;font-weight:bold">REST</span>
    <span style="color:#080;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Client</span>
      attr_accessor <span style="color:#A60">:consumer_key</span>, <span style="color:#A60">:consumer_secret</span>, <span style="color:#A60">:access_token</span>, <span style="color:#A60">:access_token_secret</span>

      <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">initialize</span>
        <span style="color:#080;font-weight:bold">yield</span> <span style="color:#069">self</span>
      <span style="color:#080;font-weight:bold">end</span>
    <span style="color:#080;font-weight:bold">end</span>
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>
</pre> <p>意外的简单吧，只需要在初始化方法中 yield self 就可以了，这样 initialize 方法都不需要参数，更加灵活</p> <p>当然可以改进一下，就像之前的 File 一样，加上 block_given? 方法，来兼容普通的 new 方式。</p> <p>回到刚才提到的 Rails route 的例子，肯定有熟悉的同学会说，我的 Rails 路由不是上面这样的， 它是这样的：</p> <pre class=src lang=ruby>
routes = <span style="color:#036;font-weight:bold">Router</span>.new <span style="color:#080;font-weight:bold">do</span>
  match <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">/about</span><span style="color:#710">'</span></span> =&gt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">home#about</span><span style="color:#710">'</span></span>
  match <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">/users</span><span style="color:#710">'</span></span> =&gt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">users#index</span><span style="color:#710">'</span></span>
<span style="color:#080;font-weight:bold">end</span>
</pre> <p>看来区别就是 do 后面的那个 |r| 以及 block 中对应的 r(Router) 对象了。</p> <p>那么如何实现这种更简洁的写法呢？秘诀就是 instance_eval 了，这个方法可以改变代码的运行上下文。</p> <p>如果没有 instance_eval 的话，在 blocks 中调用方法（比如例子中的 match），那它所属的对象就是 main (执行 irb 的顶层对象).</p> <p>而使用了 instance_eval 之后，上下文就进入了 router 对象内部，那么就能调用到 router 对象的 match 方法了，直接看结果：</p> <pre class=src lang=ruby>
<span style="color:#080;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Router</span>
  <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">initialize</span>(&amp;block)
    instance_eval &amp;block
  <span style="color:#080;font-weight:bold">end</span>
  <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">match</span>(route)
    puts route
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>

routes = <span style="color:#036;font-weight:bold">Router</span>.new <span style="color:#080;font-weight:bold">do</span>
  match <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">/about</span><span style="color:#710">'</span></span> =&gt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">home#about</span><span style="color:#710">'</span></span>
<span style="color:#080;font-weight:bold">end</span>
</pre> <p>这样就可以了，回到之前的 Twitter 例子，我们也可以用同样的方法去掉 config 参数。</p> <p>不过这里我们要更进一步，实现下面的调用方法。</p> <pre class=src lang=ruby>
client = <span style="color:#036;font-weight:bold">Twitter</span>::<span style="color:#036;font-weight:bold">REST</span>::<span style="color:#036;font-weight:bold">Client</span>.new({<span style="color:#606">consumer_key</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">YOUR_CONSUMER_KEY</span><span style="color:#710">&quot;</span></span>}) <span style="color:#080;font-weight:bold">do</span>
  consumer_secret = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">YOUR_CONSUMER_SECRET</span><span style="color:#710">&quot;</span></span>
  access_token = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">YOUR_ACCESS_TOKEN</span><span style="color:#710">&quot;</span></span>
  access_token_secret = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">YOUR_ACCESS_SECRET</span><span style="color:#710">&quot;</span></span>
<span style="color:#080;font-weight:bold">end</span>
</pre> <p>即可以直接在 new 中传参，也可以使用 block. 其实也很简单，只要知道 Ruby 元编程中的 send 方法就可以了</p> <pre class=src lang=ruby>
<span style="color:#080;font-weight:bold">module</span> <span style="color:#B06;font-weight:bold">Twitter</span>
  <span style="color:#080;font-weight:bold">module</span> <span style="color:#B06;font-weight:bold">REST</span>
    <span style="color:#080;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Client</span>
      attr_accessor <span style="color:#A60">:consumer_key</span>, <span style="color:#A60">:consumer_secret</span>, <span style="color:#A60">:access_token</span>, <span style="color:#A60">:access_token_secret</span>
      <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">initialize</span>(options = {}, &amp;block)
        options.each { |k,v| send(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">#{</span>k<span style="font-weight:bold;color:#666">}</span></span><span style="color:#D20">=</span><span style="color:#710">&quot;</span></span>, v) }
        instance_eval(&amp;block) <span style="color:#080;font-weight:bold">if</span> block_given?
      <span style="color:#080;font-weight:bold">end</span>
    <span style="color:#080;font-weight:bold">end</span>
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>
</pre> <p>好了，最后说一下， initialize 方法的参数中，使用了 &amp;block 这样的写法，这个 &amp; 符号的作用下面就来解释一下：</p> <p>使用 &amp;block, 就意味着把 block 转换成了 Proc, 因为 instance_eval 接收的是一个对象，但 block 不能直接用作对象来看待，因此需要先转为 Proc.</p> <p>所以我们下面先讲讲 Proc &#8230;</p> <p>Proce 是对象，可以用来表示一个代码块（block of code），和 JavasScript 中的匿名函数差不多，只不过 Ruby 并不能直接把函数作为参数，所以需要转一下。</p> <p>下面是创建 Proc 的几种方法：</p> <pre class=src lang=ruby>
p = proc { |x, y| x + y }
p = <span style="color:#036;font-weight:bold">Kernel</span>.proc { |x, y| x + y }
p = <span style="color:#036;font-weight:bold">Proc</span>.new { |x, y| x + y }
</pre> <p>我觉得了解一下就可以了，有了第一种，完全没有使用其他两种方式的必要。</p> <p>同样的，调用 Proc 也有多种方式：</p> <pre class=src lang=ruby>
p.call(<span style="color:#00D">4</span>, <span style="color:#00D">2</span>)
p.(<span style="color:#00D">4</span>, <span style="color:#00D">2</span>)
p === [<span style="color:#00D">4</span>, <span style="color:#00D">2</span>]
</pre> <p>call 是最容易接受的方式，至于直接的 .() 方法，它其实不限于 Proc, 任何实现了 call 方法的 Ruby 对象都可以这样调用。</p> <pre class=src lang=ruby>
<span style="color:#080;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Carly</span>
  <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">call</span>(who)
    <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">call </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">#{</span>who<span style="font-weight:bold;color:#666">}</span></span><span style="color:#D20">, maybe</span><span style="color:#710">&quot;</span></span>
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>

c = <span style="color:#036;font-weight:bold">Carly</span>.new
c.(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">me</span><span style="color:#710">&quot;</span></span>) <span style="color:#777"># =&gt; &quot;call me, maybe&quot;</span>
</pre> <p>而 <code>===</code> 的写法实质上是模式匹配，把 4 和 2 匹配到 x 和 y 上，是的 Ruby 这这方面是支持模式匹配的。再举个例子：</p> <pre class=src lang=ruby>
even = proc { |x| x % <span style="color:#00D">2</span> == <span style="color:#00D">0</span> }
<span style="color:#080;font-weight:bold">case</span> <span style="color:#00D">11</span>
<span style="color:#080;font-weight:bold">when</span> even
  <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">number is even</span><span style="color:#710">&quot;</span></span>
<span style="color:#080;font-weight:bold">else</span>
  <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">number is odd</span><span style="color:#710">&quot;</span></span>
<span style="color:#080;font-weight:bold">end</span>
</pre> <p>可能这样一来对于 <code>===</code> 的写法就更好理解了。</p> <p>介绍了 Proc 后，我们来看看它和 Lambda 有什么区别把。直接看表吧，这种对比还是看表更直观。</p> <table> <tr><th></th><th>class</th><th>lambda?</th><th>proc?</th></tr> <tr><td>lambda</td><td>Proc</td><td>true</td><td>false</td></tr> <tr><td>proc</td><td>Proc</td><td>false</td><td>true</td></tr> </table> <p>class, lambda?, proc? 都是方法名，依靠这三个方法的判断，可以有一个大致的了解了吧。。。</p> <p>好了，其实它两主要就两个区别，一是接收参数，二是返回的语义，一个入一个出，都不一样。</p> <pre class=src lang=ruby>
l = lambda { |x, y| puts <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">x: </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">#{</span>x<span style="font-weight:bold;color:#666">}</span></span><span style="color:#D20">, y: </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">#{</span>y<span style="font-weight:bold;color:#666">}</span></span><span style="color:#710">&quot;</span></span> }
p = proc { |x, y| puts<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">x:</span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">#{</span>x<span style="font-weight:bold;color:#666">}</span></span><span style="color:#D20">, y:</span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">#{</span>y<span style="font-weight:bold;color:#666">}</span></span><span style="color:#710">&quot;</span></span> }
</pre> <p>l 和 p 都可定义了两个参数 x 和 y, 如果我们只传一个会发生什么呢？</p> <pre class=src lang=ruby>
p.call(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Ohai</span><span style="color:#710">&quot;</span></span>) <span style="color:#777">#=&gt; x: Ohai, y:</span>
l.call(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Ohai</span><span style="color:#710">&quot;</span></span>) <span style="color:#777">#=&gt; ArgumentError: wrong number of arguments (1 for 2)</span>
</pre> <p>看来 lambda 更严格，而 proc 更灵活</p> <p>那如果传三个参数呢，不难推测，lambda 依旧报错，proc 只取了前两个参数。</p> <p>再看下对于返回语义的问题，直接看代码：</p> <pre class=src lang=ruby>
<span style="color:#080;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">SomeClass</span>
  <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">method_that_calls_proc_or_lambda</span>(procy)
    puts <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">calling </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">#{</span>proc_or_lambda(procy)<span style="font-weight:bold;color:#666">}</span></span><span style="color:#D20"> now!</span><span style="color:#710">&quot;</span></span>
    procy.call
    puts <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">#{</span>proc_or_lambda(procy)<span style="font-weight:bold;color:#666">}</span></span><span style="color:#D20"> gets called!</span><span style="color:#710">&quot;</span></span>
  <span style="color:#080;font-weight:bold">end</span>

  <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">proc_or_lambda</span>(proc_like_thing)
    proc_like_thing.lambda? ? <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Lambda</span><span style="color:#710">&quot;</span></span> : <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Proc</span><span style="color:#710">&quot;</span></span>
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>

c = <span style="color:#036;font-weight:bold">SomeClass</span>.new
c.method_that_calls_proc_or_lambda lambda { <span style="color:#080;font-weight:bold">return</span> }
c.method_that_calls_proc_or_lambda proc { <span style="color:#080;font-weight:bold">return</span> } <span style="color:#777">#=&gt; 'block in &lt;main&gt;': unexpected return (LocalJumpError)</span>
</pre> <p>在 lambda 中 return 就是结束的意思，代码执行完毕。而 proc 中 return 会报错。</p> <p>这是因为 proc 被创建的上下文是 main, 就是 irb 中的顶层对象，不信你直接在 irb 中输入 return, 会报一样的错。</p> <p>好了，我们回到那个 &amp; 符号，它其实不限于和 block 组合，实际上，它是一个语法糖，会调用 to_proc 方法。</p> <pre class=src lang=ruby>
words.map { |s| s.length }
words.map(&amp;<span style="color:#A60">:length</span>)
</pre> <p>上面两行代码是等价的，那么它们为什么等价呢？我们可以试着自己实现一下。</p> <p>我们来分析一下 <code>:length</code> 是一个 symbol, 那么我们又要开始元编程了。</p> <pre class=src lang=ruby>
  <span style="color:#080;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Symbol</span>
    <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">to_proc</span>
      puts <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">to proc ...</span><span style="color:#710">&quot;</span></span>
    <span style="color:#080;font-weight:bold">end</span>
  <span style="color:#080;font-weight:bold">end</span>

  [<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">hello</span><span style="color:#710">&quot;</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">world</span><span style="color:#710">&quot;</span></span>].map(&amp;<span style="color:#A60">:length</span>)

<span style="color:#777"># =&gt; to proc ...</span>
<span style="color:#777"># =&gt; Traceback (most recent call last):</span>
<span style="color:#777"># =&gt; `&lt;main&gt;': wrong argument type Symbol (expected Proc) (TypeError)</span>
</pre> <p>可见 to proc &#8230; 已经被执行了，后面报了错，它期望又个 Proc, 那么我们满足它。</p> <pre class=src lang=ruby>
<span style="color:#080;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Symbol</span>
  <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">to_proc</span>
    puts <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">to proc ...</span><span style="color:#710">&quot;</span></span>
    proc {}
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>

[<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">hello</span><span style="color:#710">&quot;</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">world</span><span style="color:#710">&quot;</span></span>].map(&amp;<span style="color:#A60">:length</span>) <span style="color:#777"># =&gt; to proc ...</span>
</pre> <p>这下不报错了，然后我们要加入参数，就是 array 中的元素，然后调用这个元素的 <code>:length</code> 方法。</p> <p>这里 <code>:length</code> 是 Symbol 类的一个实例，所以就是 self, 那么结合起来可以这样写：</p> <pre class=src lang=ruby>
<span style="color:#080;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Symbol</span>
  <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">to_proc</span>
    proc { |obj| obj.send(<span style="color:#069">self</span>) }
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>

[<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">hello</span><span style="color:#710">&quot;</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">world</span><span style="color:#710">&quot;</span></span>].map(&amp;<span style="color:#A60">:length</span>)
</pre> <p>当然这样的写法还有很大改进空间，之前我们已经知道，lambda 比 proc 更严格，这里使用 lambda 更合适。</p> <p>另外，这样的写法不适合有参数的情况，比如下面这样：</p> <pre class=src lang=ruby>
[<span style="color:#00D">1</span>, <span style="color:#00D">2</span>, <span style="color:#00D">3</span>].inject(<span style="color:#00D">0</span>) { |result, element| result + element } <span style="color:#777"># =&gt; 6</span>
[<span style="color:#00D">1</span>, <span style="color:#00D">2</span>, <span style="color:#00D">3</span>].inject(&amp;<span style="color:#A60">:+</span>)
</pre> <p>inject 方法接收两个参数，这个例子中是把它们相加，那么如果用我们的实现的话，就会报错，因为我们没有处理接收参数的情况。</p> <p>不过改动也很容易：</p> <pre class=src lang=ruby>
<span style="color:#080;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Symbol</span>
  <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">to_proc</span>
    lambda { |obj, args = <span style="color:#069">nil</span>| obj.send(<span style="color:#069">self</span>, *args) }
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>

[<span style="color:#00D">1</span>, <span style="color:#00D">2</span>, <span style="color:#00D">3</span>].inject(&amp;<span style="color:#A60">:+</span>) <span style="color:#777"># =&gt; 6</span>
<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">%w(</span><span style="color:#D20">underwear should be worn on the inside</span><span style="color:#710">)</span></span>.map &amp;<span style="color:#A60">:length</span> <span style="color:#777"># =&gt; [9, 6, 2, 4, 2, 3, 6]</span>
</pre> <p>这里为了兼容有参数和没参数的情况，使用了默认值的写法 <code>args = nil</code>, 最后尴尬的发现，直接用 proc 就可以忽略不要的 args 了。改回来：</p> <pre class=src lang=ruby>
<span style="color:#080;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Symbol</span>
  <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">to_proc</span>
    proc { |obj, args| obj.send(<span style="color:#069">self</span>, *args) }
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>
</pre> <p>可见，是选择严格，还是灵活，要视情况而定。</p> <p>在一开始介绍 proc 的时候，我们就意识到，proc 可以只接收部分参数，想必有 FP 编程经验的同学已经联想到了一个关键词：curry</p> <p>下面我们就来说说柯里化。</p> <p>先看一个复杂的计算逻辑：</p> <pre class=src lang=ruby>
discriminant = lambda { |a, b, c| b**<span style="color:#00D">2</span> - <span style="color:#00D">4</span>*a*c }
discriminant.call(<span style="color:#00D">5</span>, <span style="color:#00D">6</span>, <span style="color:#00D">7</span>)
</pre> <p>如果是柯里化，我们可以这样调用：</p> <pre class=src lang=ruby>
discriminant.call(<span style="color:#00D">5</span>).call(<span style="color:#00D">6</span>).call(<span style="color:#00D">7</span>)
<span style="color:#777"># or</span>
discriminant.call(<span style="color:#00D">5</span>).call(<span style="color:#00D">6</span>).call(<span style="color:#00D">7</span>)
</pre> <p>那该怎么定义这个 lambda 呢？下面是这种算是 hard code 了。</p> <pre class=src lang=ruby>
discriminant = lambda { |a| lambda { |b| lambda { |c| b **<span style="color:#00D">2</span> - <span style="color:#00D">4</span>*a*c } } }
</pre> <p>当然 Ruby 提供了 curry() 方法，因此只需要这样：</p> <pre class=src lang=ruby>
discriminant = lambda { |a, b, c| b**<span style="color:#00D">2</span> - <span style="color:#00D">4</span>*a*c }.curry
</pre> <p>下面我们用 curry 来把几个 lambda 抽象出一个更抽象的 lambda &#8230;</p> <pre class=src lang=ruby>
sum_ints = lambda <span style="color:#080;font-weight:bold">do</span> |start, stop|
  (start..stop).inject { |sum, x| sum + x }
<span style="color:#080;font-weight:bold">end</span>

sum_of_squares = lambda <span style="color:#080;font-weight:bold">do</span> |start, stop|
  (start..stop).inject { |sum, x| sum + x*x }
<span style="color:#080;font-weight:bold">end</span>

sum_of_cubes = lambda <span style="color:#080;font-weight:bold">do</span> |start, stop|
  (start..stop).inject { |sum, x| sum + x*x*x }
<span style="color:#080;font-weight:bold">end</span>
</pre> <p>三个 lambda, 干的事情差阿布多，区别就在 inject 后传的 block. 因此很容易想到把它给抽取出来。</p> <pre class=src lang=ruby>
sum = lambda <span style="color:#080;font-weight:bold">do</span> |fun, start, stop|
  (start..stop).inject { |sum, x| sum + fun.call(x) }
<span style="color:#080;font-weight:bold">end</span>
</pre> <p>这样就能基于这个 sum 来构建出上面的三个 lambda 了。</p> <pre class=src lang=ruby>
sum_of_ints = sum.(lambda { |x| x }, <span style="color:#00D">1</span>, <span style="color:#00D">10</span>)
sum_of_squares = sum.(lambda { |x| x*x }, <span style="color:#00D">1</span>, <span style="color:#00D">10</span>)
sum_of_cubes = sum.(lambda { |x| x*x*x }, <span style="color:#00D">1</span>, <span style="color:#00D">10</span>)
</pre> <p>不过这样的写法还是需要一次性把三个参数都给出，而使用 curry 就能实现：</p> <pre class=src lang=ruby>
sum_of_squares = sum.curry.(lambda { |x| x*x })
sum_of_squares.(<span style="color:#00D">1</span>).(<span style="color:#00D">10</span>) =&gt; <span style="color:#00D">385</span>
sum_of_squares.(<span style="color:#00D">50</span>).(<span style="color:#00D">100</span>) =&gt; <span style="color:#00D">295475</span>
</pre> <p>最后来讲一下 Lazy Enumerable, 熟悉 FP 的同学肯定也是懂的都懂了，直接看例子：</p> <pre class=src lang=ruby>
<span style="color:#00D">1</span>.upto(<span style="color:#036;font-weight:bold">Float</span>::<span style="color:#036;font-weight:bold">INFINITY</span>).map { |x| x * x }.take(<span style="color:#00D">10</span>) <span style="color:#777">#=&gt; [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span>
</pre> <p>是不是很厉害，才怪。。。等着卡死吧。。。</p> <p>那怎么才能直接从 1 遍历到无限呢？当然不是把所有整数都直接生成并加载到内存，那也太夸张了。</p> <p>让我们深入理解一下， <code>1.upto(Float::INFINITY)</code> 的返回值是一个 <code>Enumerator</code> . 现在看来这个类还不够牛逼，我们来学习一下一个更厉害的类 <code>Enumerator::Lazy</code> .</p> <p>试试下面的代码：</p> <pre class=src lang=ruby>
<span style="color:#00D">1</span>.upto(<span style="color:#036;font-weight:bold">Float</span>::<span style="color:#036;font-weight:bold">INFINITY</span>).lazy.map { |x| x * x }
</pre> <p>它的返回值是 <code>#&lt;Enumerator::Lazy: #&lt;Enumerator::Lazy: #&lt;Enumerator: 1:upto(Infinity)&gt;&gt;:map&gt;</code> 再试试下面两行：</p> <pre class=src lang=ruby>
<span style="color:#00D">1</span>.upto(<span style="color:#036;font-weight:bold">Float</span>::<span style="color:#036;font-weight:bold">INFINITY</span>).lazy.map { |x| x * x }.take(<span style="color:#00D">10</span>)
</pre> <p>返回 <code>#&lt;Enumerator::Lazy: #&lt;Enumerator::Lazy: #&lt;Enumerator::Lazy: #&lt;Enumerator: 1:upto(Infinity)&gt;&gt;:map&gt;:take(10)&gt;</code></p> <pre class=src lang=ruby>
<span style="color:#00D">1</span>.upto(<span style="color:#036;font-weight:bold">Float</span>::<span style="color:#036;font-weight:bold">INFINITY</span>).lazy.map { |x| x * x }.take(<span style="color:#00D">10</span>).to_a
</pre> <p>返回 <code>[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</code></p> <p>看到没，只有到了最后的 <code>to_a</code> 方法，值才会被真正计算出来。知道了 lazy 的用法，下面我们试着自己实现它。</p> <p>首先我们之前看到了实现 Lazy 功能的类是 <code>Enumerator::Lazy</code> . 那么我们可以模仿它，自己写个类，就叫它 <code>Lax</code> 吧。</p> <pre class=src lang=ruby>
<span style="color:#080;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Lax</span> &lt; <span style="color:#036;font-weight:bold">Enumerator</span>
<span style="color:#080;font-weight:bold">end</span>

<span style="color:#080;font-weight:bold">module</span> <span style="color:#B06;font-weight:bold">Enumerable</span>
  <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">lax</span>
    <span style="color:#036;font-weight:bold">Lax</span>.new(<span style="color:#069">self</span>)
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>
</pre> <p>那么具体实现呢？这里要先介绍一下 <code>Enumberator</code> 的用法。</p> <pre class=src lang=ruby>
e = <span style="color:#036;font-weight:bold">Enumerator</span>.new <span style="color:#080;font-weight:bold">do</span> |yielder|
  [<span style="color:#00D">1</span>,<span style="color:#00D">2</span>,<span style="color:#00D">3</span>].each <span style="color:#080;font-weight:bold">do</span> |val|
    yielder &lt;&lt; val
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>

e.next <span style="color:#777"># =&gt; 1</span>
e.next <span style="color:#777"># =&gt; 2</span>
e.next <span style="color:#777"># =&gt; 3</span>
e.next <span style="color:#777"># =&gt; StopIteration: iteration reached an end</span>
</pre> <p>是不是和之前的 Counter 类很像，当然，原理完全不同。。。</p> <p>这里的 <code>yielder &lt;&lt; val</code> 定义了下一个 yield 的指令，而不是值本身，这样一来，每次调用 Enumberator 的 next 方法，它就能计算出下一个值并返回。</p> <p>有了这些前置知识，我们可以写写出我们的 Lax 的初始化方法</p> <pre class=src lang=ruby>
<span style="color:#080;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Lax</span> &lt; <span style="color:#036;font-weight:bold">Enumerator</span>
  <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">initialize</span>(receiver)
    <span style="color:#080;font-weight:bold">super</span>() <span style="color:#080;font-weight:bold">do</span> |yielder|
      receiver.each <span style="color:#080;font-weight:bold">do</span> |val|
        puts <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">add: </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">#{</span>val<span style="font-weight:bold;color:#666">}</span></span><span style="color:#710">&quot;</span></span>
        yielder &lt;&lt; val
      <span style="color:#080;font-weight:bold">end</span>
    <span style="color:#080;font-weight:bold">end</span>
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>

lax = <span style="color:#036;font-weight:bold">Lax</span>.new([<span style="color:#00D">1</span>, <span style="color:#00D">2</span>, <span style="color:#00D">3</span>])
lax.map { |x| puts <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">map: </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">#{</span>x<span style="font-weight:bold;color:#666">}</span></span><span style="color:#710">&quot;</span></span>; x }

<span style="color:#777"># =&gt; add: 1</span>
<span style="color:#777"># =&gt; map: 1</span>
<span style="color:#777"># =&gt; add: 2</span>
<span style="color:#777"># =&gt; map: 2</span>
<span style="color:#777"># =&gt; add: 3</span>
<span style="color:#777"># =&gt; map: 3</span>
</pre> <p>添加了一个 puts 方便调试。可见我们成功使用到了 yielder 的功能。</p> <p>之后是实现 <code>map</code> 方法， 它接收一个 block, 然后由于可以链式调用，最后应该返回 self.</p> <pre class=src lang=ruby>
<span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">map</span>(&amp;block)
  <span style="color:#036;font-weight:bold">Lax</span>.new(<span style="color:#069">self</span>)
<span style="color:#080;font-weight:bold">end</span>
</pre> <p>具体的实现需要两参数， yielder 和 val, 因此可以这样</p> <pre class=src lang=ruby>
<span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">map</span>(&amp;block)
  <span style="color:#036;font-weight:bold">Lax</span>.new(<span style="color:#069">self</span>) <span style="color:#080;font-weight:bold">do</span> |yielder, val|
    yielder &lt;&lt; block.call(val)
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>
</pre> <p>让每个 val 都被 block 调用过后 (比如 x + 1 ) 再进入 yielder</p> <p>那么相应的，初始化方法也需要修改：</p> <pre class=src lang=ruby>
<span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">initialize</span>(receiver)
  <span style="color:#080;font-weight:bold">super</span>() <span style="color:#080;font-weight:bold">do</span> |yielder|
    receiver.each <span style="color:#080;font-weight:bold">do</span> |val|
      <span style="color:#080;font-weight:bold">if</span> block_given?
        <span style="color:#080;font-weight:bold">yield</span>(yielder, val)
      <span style="color:#080;font-weight:bold">else</span>
        yielder &lt;&lt; val
      <span style="color:#080;font-weight:bold">end</span>
    <span style="color:#080;font-weight:bold">end</span>
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>
</pre> <p>现在我们已经可以执行下面的代码了：</p> <pre class=src lang=ruby>
<span style="color:#00D">1</span>.upto(<span style="color:#036;font-weight:bold">Float</span>::<span style="color:#036;font-weight:bold">INFINITY</span>).lax.map { |x| x*x }.map { |x| x+<span style="color:#00D">1</span> }.first(<span style="color:#00D">5</span>) <span style="color:#777"># =&gt; [2, 5, 10, 17, 26]</span>
</pre> <p>之后就是实现 <code>take</code> 方法了。有了 map 的例子， take 就很容易了</p> <pre class=src lang=ruby>
<span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">take</span>(n)
  taken = <span style="color:#00D">0</span>
  <span style="color:#036;font-weight:bold">Lax</span>.new(<span style="color:#069">self</span>) <span style="color:#080;font-weight:bold">do</span> |yielder, val|
    <span style="color:#080;font-weight:bold">if</span> taken &lt; n
      yielder &lt;&lt; val
      taken += <span style="color:#00D">1</span>
    <span style="color:#080;font-weight:bold">else</span>
      raise <span style="color:#036;font-weight:bold">StopIteration</span>
    <span style="color:#080;font-weight:bold">end</span>
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>
</pre> <p>这里的 <code>StopIteration</code> 不陌生吧，之前的测试中，一直调用 next 到最后就会报这个错。</p> <p>把这个错误的 rescue 加入到初始化方法后，整个实现的完整代码如下：</p> <pre class=src lang=ruby>
<span style="color:#080;font-weight:bold">module</span> <span style="color:#B06;font-weight:bold">Enumerable</span>
  <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">lax</span>
    <span style="color:#036;font-weight:bold">Lax</span>.new(<span style="color:#069">self</span>)
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>

<span style="color:#080;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Lax</span> &lt; <span style="color:#036;font-weight:bold">Enumerator</span>
  <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">initialize</span>(receiver)
    <span style="color:#080;font-weight:bold">super</span>() <span style="color:#080;font-weight:bold">do</span> |yielder|
      <span style="color:#080;font-weight:bold">begin</span>
        receiver.each <span style="color:#080;font-weight:bold">do</span> |val|
          <span style="color:#080;font-weight:bold">if</span> block_given?
            <span style="color:#080;font-weight:bold">yield</span>(yielder, val)
          <span style="color:#080;font-weight:bold">else</span>
            yielder &lt;&lt; val
          <span style="color:#080;font-weight:bold">end</span>
        <span style="color:#080;font-weight:bold">end</span>
      <span style="color:#080;font-weight:bold">rescue</span> <span style="color:#036;font-weight:bold">StopIteration</span>
      <span style="color:#080;font-weight:bold">end</span>
    <span style="color:#080;font-weight:bold">end</span>
  <span style="color:#080;font-weight:bold">end</span>

  <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">map</span>(&amp;block)
    <span style="color:#036;font-weight:bold">Lax</span>.new(<span style="color:#069">self</span>) <span style="color:#080;font-weight:bold">do</span> |yielder, val|
      yielder &lt;&lt; block.call(val)
    <span style="color:#080;font-weight:bold">end</span>
  <span style="color:#080;font-weight:bold">end</span>

  <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">take</span>(n)
    taken = <span style="color:#00D">0</span>
    <span style="color:#036;font-weight:bold">Lax</span>.new(<span style="color:#069">self</span>) <span style="color:#080;font-weight:bold">do</span> |yielder, val|
      <span style="color:#080;font-weight:bold">if</span> taken &lt; n
        yielder &lt;&lt; val
        taken += <span style="color:#00D">1</span>
      <span style="color:#080;font-weight:bold">else</span>
        raise <span style="color:#036;font-weight:bold">StopIteration</span>
      <span style="color:#080;font-weight:bold">end</span>
    <span style="color:#080;font-weight:bold">end</span>
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>
</pre> <p>来个完整的例子：</p> <pre class=src lang=ruby>
<span style="color:#00D">1</span>.upto(<span style="color:#036;font-weight:bold">Float</span>::<span style="color:#036;font-weight:bold">INFINITY</span>).lax.map { |x| x*x }.map { |x| x+<span style="color:#00D">1</span> }.take(<span style="color:#00D">5</span>).to_a
<span style="color:#777"># =&gt; [2, 5, 10, 17, 26]</span>
</pre> </article> <script src="/assets/javascripts/all-70879c36.js"></script> <script src="/assets/javascripts/highlight-e7667caa.js"></script> <script>hljs.initHighlightingOnLoad()</script> <div id=github-comments></div> <script src="/assets/javascripts/comment-ddc93c2f.js" id=github-comment data-ssl=true data-theme=green data-username=teddy-ma data-repo="teddy-ma.github.io" data-page-id="posts/ruby-closure-note"></script> </body> </html>