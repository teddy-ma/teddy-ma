<!doctype html>
<html lang="zh-cmn-Hans" class="han-init">
  <head>
    <meta charset="utf-8">
    <title>编程青年 - 实战 tell dont ask 原则</title>
    <meta name="description" content="编程青年的博客，记录着软件开发中的点点滴滴">
    <meta name="copyright" content="Ma Lucheng 2014-2015">
    <meta name="generator" content="pandoc">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192" href="/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">

    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">

    <link href="/css/app.css" rel="stylesheet">
    <link href="//cdn.bootcss.com/highlight.js/8.9.1/styles/solarized_light.min.css" rel="stylesheet">
  </head>

  <body class="container">
    <header class="global-header row">
      <h1 class="global-header__logo four columns"><a href="/" class="blog-title-link">编程青年</a></h1>
      <nav id="menu1" class="navbar eight columns">
        <ul class="navbar-list">
          
            <li class="navbar-item">
              <a href="/posts/" class="navbar-link" target='_self'>posts</a>
            </li>
          
            <li class="navbar-item">
              <a href="/essays/" class="navbar-link" target='_self'>essays</a>
            </li>
          
            <li class="navbar-item">
              <a href="/reading/" class="navbar-link" target='_self'>reading</a>
            </li>
          
            <li class="navbar-item">
              <a href="http://songofcode.com/how-to-learn-emacs-chinese-edition/" class="navbar-link" target='_blank'>emacs</a>
            </li>
          
            <li class="navbar-item">
              <a href="/about/" class="navbar-link" target='_self'>about</a>
            </li>
          
            <li class="navbar-item">
              <a href="https://github.com/teddy-ma/" class="navbar-link" target='_blank'>github</a>
            </li>
          
        </ul>
      </nav>
      <nav id="menu2" class="path-nav path-nav-top-right">
        <a href="#menu2" class="path-nav-expander">
          <div class="ball"></div>
        </a>
        <a href="#" class="path-nav-close"></a>
        <ul>
          
            <li>
              <a href="/posts/" target='_self'>posts</a>
            </li>
          
            <li>
              <a href="/essays/" target='_self'>essays</a>
            </li>
          
            <li>
              <a href="/reading/" target='_self'>reading</a>
            </li>
          
            <li>
              <a href="http://songofcode.com/how-to-learn-emacs-chinese-edition/" target='_blank'>emacs</a>
            </li>
          
            <li>
              <a href="/about/" target='_self'>about</a>
            </li>
          
            <li>
              <a href="https://github.com/teddy-ma/" target='_blank'>github</a>
            </li>
          
        </ul>
      </nav>
    </header>

    <main id="baseline" role="main" class="page-main typo yue row">
      <div class="section typeset twelve columns">
        <!-- 文章视图 -->
<article>
  <h1 id="实例讲解-tell-dont-ask-原则">实例讲解 tell don't ask 原则</h1>
<p>在开发签到（补签）功能时，我的一些想法。</p>
<p>签到功能是一个接口非常简单，但内部实现不算简单的功能。</p>
<p>初期功能就是最简单的一个点击按钮发送请求，没有后台管理，用户当然也只能签当天的到。</p>
<p>后来开发了一个后台管理的补签功能，但只有管理员能才做。代码如下：</p>
<pre class="ruby"><code># 补签
def repair_check_in(user, date)
  behavior = user.user_behavior

  return [false, 0, &quot;当天已经签过了，不可重复签到&quot;] if user.check_ins.where(the_date: date).present?

  previous_check_in = user.check_ins.where(the_date: date - 1.days).first

  # 当天连续签到次数的快照（签到后）
  checkin_count = previous_check_in.present? ? (previous_check_in.checkin_count + 1) : 1

  # 获取距要补签处最近的断点前一次签到记录以及是否需要修改用户continuous_checkin_count
  nearest_check_in, modify_behavior = nearest_uncheck(user, date)

  # 钻石如何计算, 是否要补上当天签到应加的钻石
  # 计算钻石数量
  diamond_count = checkin_reward(checkin_count - 1)

  checkin = user.check_ins.new(the_date: date, diamond: diamond_count, checkin_count: checkin_count)

  if checkin.save
    # 奖励钻石
    DiamondService.new.add_diamond(user, diamond_count, DiamondLog::ChangeType::CHECKIN)
    new_checkin_count = checkin_count

    if nearest_check_in.present?
      # 下个断点最终连续签到次数
      continuous_checkin_count = nearest_check_in.checkin_count + checkin_count

      # 更新下个断点最终连续签到次数
      nearest_check_in.update_attributes(checkin_count: continuous_checkin_count)

      # 更新连续签到天数
      behavior.update_attributes(continuous_checkin_count: continuous_checkin_count) if modify_behavior

      new_checkin_count = continuous_checkin_count
    end


    # 更新历史最大签到天数
    if new_checkin_count &gt; behavior.max_checkin_count
      behavior.update_attributes(max_checkin_count: new_checkin_count)
    end

    message = &quot;补签成功，连续打卡 #{ behavior.continuous_checkin_count } 天，获得 #{diamond_count} 颗钻石&quot;
    return [true, diamond_count, message]
  end
end</code></pre>
<p>这次我要开发的任务就是让用户在前台也可以补签。</p>
<p>先说下签到的相关属性：签到日期，连续签到数, 和最大连续签到数</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">record_on</th>
<th style="text-align: left;">continuous_checkin_count</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">2015-11-11</td>
<td style="text-align: left;">1</td>
</tr>
<tr class="even">
<td style="text-align: left;">2015-11-12</td>
<td style="text-align: left;">2</td>
</tr>
<tr class="odd">
<td style="text-align: left;">2015-11-14</td>
<td style="text-align: left;">1</td>
</tr>
</tbody>
</table>
<p>其中每次签到都会创建一条数据库记录, 并记下当前的连续签到数(相当于快照)</p>
<p>而最大连续签到数是单独存在 redis 中的.</p>
<p>后台的管理逻辑上面已经放出来了。</p>
<p>那么我要做的这个前台的版本有如下不同：</p>
<ol type="1">
<li>用户只能补签7天以内的到</li>
<li>补签一次需要 3000 积分，不足则不能签到</li>
<li>如果选择的补签时间是今天，则按照正常签到处理（不然也太坑了）</li>
</ol>
<p>按照 TDD 的思想，我先写下了如下的测试用例：</p>
<pre class="ruby"><code>test &quot;repair checkin with no date&quot; do
  post :repair, token: @user.token, format: :json
  assert response.body.include?(&quot;请选择签到日期&quot;)
end

test &quot;repair checkin with invalid date&quot; do
  post :repair, token: @user.token, date: &quot;abcd&quot;, format: :json
  assert response.body.include?(&quot;请选择签到日期&quot;)
end

test &quot;repair checkin with few diamond&quot; do
  post :repair, token: @user.token, date: &quot;2015-11-11&quot;, format: :json
  assert response.body.include?(&quot;钻石不足, 无法补签&quot;)
end

test &quot;repair checkin with enough diamond&quot; do
  @user.behavior.update(envious_count: 10000)
  post :repair, token: @user.token, date: &quot;2015-11-11&quot;, format: :json
  assert_equal 7000, @user.behavior.reload.envious_count
  assert response.body.include?(&quot;补签成功&quot;)
end</code></pre>
<p>然后复制拷贝了原来的补签逻辑，稍作修改，就实现了一个基本的实现。 当然这样的代码虽然可以工作，但是一定会被以后看到这段代码的其他程序员(或自己)所鄙视。 那么在保证 app 的调用无碍的前提下，我又开了一个分支开始重构。</p>
<pre class="shell"><code>git checkout -b refactor/checkin_repair</code></pre>
<p>Tell Don't Ask 是一种 OO 的编程思想.</p>
<blockquote>
<p>Good OOP is about telling objects what you want done, not querying an object and acting on its behalf. Data and operations that depend on that data belong in the same object.</p>
</blockquote>
<p>告诉对象你想要它做什么, 而不是去查询对象的状态然后去告诉它下一步怎么走.</p>
<p>个人经验, 可以根据条件语句的多少作为判断一段程序的 OO 程度.</p>
<p>观察上面的补签功能的代码, 可以发现有着很多典型的 &quot;状态查询&quot; 的语句, 我们可以先总结它在做的事情,</p>
<p>再进行更 OO 的转换.</p>
<p>上面的这段代码大概做了这么几件事:</p>
<ol type="1">
<li>计算补签后连续签到次数</li>
<li>更新补签后的最后一条记录的连续签到快照</li>
<li>更新最大连续签到数</li>
</ol>
<p>下面就要开始把 query 的语句都转换成 command 形式了.</p>
<p>不过饭要一口口吃, 先把那些一看就是面条代码的大段逻辑移到模型中.</p>
<pre class="ruby"><code># 补签 (后台)
# @param user 补签的用户
# @param date 补签的日期
def repair_check_in(user, date)
  behavior = user.user_behavior
  return [false, 0, &quot;当天已经签过了，不可重复签到&quot;] if user.check_ins.where(the_date: date).present?
  # 当天连续签到次数的快照（签到后）
  checkin_count = CheckIn.calc_checkin_count_after_repair(user, date)
  # 获取距要补签处最近的断点前一次签到记录以及是否需要修改用户continuous_checkin_count
  nearest_check_in, modify_behavior = CheckIn.nearest_uncheck(user, date)
  return CheckIn.create_repair(behavior, nearest_check_in, modify_behavior, user, date, checkin_count)
end  </code></pre>
<p>这样一来至少看上去清爽多了. 理一下逻辑:</p>
<ol type="1">
<li>得到补签后(可能)会改变的最大连续签到数的值</li>
<li>得到最近的一次<em>会被影响</em>的签到记录(快照)</li>
<li>使用工厂方法创建一个 CheckIn 对象并持久化到数据库中.</li>
</ol>
<p>不难发现这样写只是简单地挪动了代码的位置, 并没有思想上的变化.</p>
<p>代码中的问题还是很多, 比如 checkin_count 明明是 CheckIn 自己能得到的一个值, 却被放在外部,</p>
<p>然后被再次调用. 比如 nearest_uncheck 这个方法很不直观, 无法理解它在说什么.</p>
<p>create_repair 看似是一个工厂方法, 感觉像设计过的, 实际上要传的参数太多, 也很难理解.</p>
<p>回到 tell don't ask 的原则.</p>
<p>看看我们使用了哪些 query (ask).</p>
<ol type="1">
<li>我们请求了补签后会造成的最大连续签到的值</li>
<li>我们请求了补签后会影响到的那个最后的签到记录(像 bool modify_behavior 这样的标示符根本不应该暴露到外部)<br />
</li>
<li>我们查询了历史最大签到数并做了比较, 然后更新如果新的最大签到数比较大的话.</li>
</ol>
<p>下面就要把思路转一下, 把代码 command (tell) 化.</p>
<p>说到 command, 总要有个对象才能下命令吧.</p>
<p>这段逻辑主要就是两个对象, CheckIn 类和 CheckIn 的实例</p>
<p>CheckIn 是一个 ActiveRecord 的子类, 因此它可以代表数据库的一张表</p>
<p>而 CheckIn 的一个实例就代表 CheckIn 表的一条记录</p>
<p>下面开始变形:</p>
<p>1 和 2 可以合并, 我不想知道补签后会造成的最大连续签到的值, 你去给我更新那条需要的记录.</p>
<p>3 改为, 给我去更新历史最大连续签到数, 我不管到底谁大谁小, 反正你把大的那个给我存下来.</p>
<pre class="ruby"><code># 补签 (后台)
# @param user 补签的用户
# @param date 补签的日期
def repair_check_in(user, date)
  behavior = user.user_behavior
  return [false, 0, &quot;当天已经签过了，不可重复签到&quot;] if user.check_ins.where(the_date: date).present?

  # commands
  CheckIn.update_continuous_checkin_count(user, date)
  CheckIn.create_repair(user, date)  
  behavior.update_max_checkin_count_after_repair(new_checkin_count)
end  </code></pre>
<pre class="ruby"><code>  create_repair(behavior, next_check_in, nearest_check_in, modify_behavior, user, date, checkin_count)</code></pre>
<p>这个方法,从它需要接收大量的参数就可以看出来还有很大的改进空间.</p>
<p>进入定法定义, 看看它的实现:</p>
<pre class="ruby"><code>def self.create_repair(behavior, next_check_in, nearest_check_in, modify_behavior, user, date, checkin_count)
  # 计算钻石数量
  diamond_count = checkin_reward(checkin_count - 1)

  checkin = user.check_ins.new(the_date: date, diamond: diamond_count, checkin_count: checkin_count)

  if checkin.save
    new_checkin_count = checkin_count

    if nearest_check_in.present?
      # 更新补签的下一天的连续签到次数
      next_check_in.update_attributes(checkin_count: next_check_in.checkin_count + checkin_count) if next_check_in.present?
      # 下个断点最终连续签到次数
      continuous_checkin_count = nearest_check_in.checkin_count + checkin_count

      # 更新下个断点最终连续签到次数
      nearest_check_in.update_attributes(checkin_count: continuous_checkin_count)

      # 更新连续签到天数
      behavior.update_attributes(continuous_checkin_count: continuous_checkin_count) if modify_behavior

      new_checkin_count = continuous_checkin_count
    end

    # 更新历史最大签到天数
    behavior.update_max_checkin_count_after_repair(new_checkin_count)

    message = &quot;补签成功&quot; #连续打卡 #{ behavior.continuous_checkin_count } 天&quot;
    return [true, diamond_count, message]
  end
end</code></pre>
<p>来看看它做了哪些事情:</p>
<ol type="1">
<li>计算钻石数量</li>
<li>构建一个 checkin 对象</li>
<li>更新补签的下一天的连续签到次数</li>
<li>获得下个断点最终连续签到次数</li>
<li>更新下个断点最终连续签到次数</li>
<li>更新历史最大签到天数</li>
</ol>
<p>其中 1 的问题非常明显, 首先使用了一个类方法来根据连续签到的次数计算本地可以获得的钻石. 这又是一个典型的&quot;拿着自己已有的数据去计算, 得到一个值后再赋值给自己&quot;的例子.</p>
<p>然后 4 和 5 又可以合并, 相当于直接给对象下命令 &quot;更新下个断点最终连续签到次数&quot;</p>
<p>重构后代码如下:</p>

</article>

      </div>
    </main> <!-- 网页主体 -->

    <!-- 评论框 -->

    <footer role="contentinfo" class="global-footer row">
      <p class="copyright">© Ma Lucheng 2014-2015 — All content is licensed under the
        <a href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons BY-SA 3.0</a>.
      </p>

      <figure class="footer-zfm">
        <img src="http://javaer.qiniudn.com/zhifuma.png" alt="支付宝二维码" />
        <figcaption>觉得文章对你有帮助，可以打赏一杯咖啡支持一下</figcaption>
      </figure>
    </footer><!-- 页脚 -->

    <script src="/js/vendor.js"></script>
    <script src="/js/app.js"></script>
    <script src="//cdn.bootcss.com/highlight.js/8.9.1/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <script>require('main').init();</script>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-68587267-1', 'auto');
      ga('send', 'pageview');
    </script>

    <script src="//cdn.bootcss.com/instantclick/3.0.1/instantclick.min.js"></script>
    <script>
      InstantClick.on('change', function() {
        var blocks = document.querySelectorAll('pre code');
        for (var i = 0; i < blocks.length; i++) {
          hljs.highlightBlock(blocks[i]);
        }
      });
    </script>

    <script type="text/javascript" src=""></script>
  </body>
</html>
