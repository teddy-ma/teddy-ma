<!doctype html> <html lang=zh-CN> <head> <title>Teddy Ma's Homepage | </title> <meta content="IE=edge" http-equiv=X-UA-Compatible> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no" name=viewport> <meta name=author content="Teddy Ma"> <meta name=description content="Teddy Ma's Personal Website"> <meta name=keywords content="programming, software engineer, code"> <link rel=stylesheet href="https://www.songofcode.com/socss/assets/toolkit/styles/toolkit.css"/> <!--[if lt IE 9]><script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--> <script>
window['_fs_debug'] = false;
window['_fs_host'] = 'fullstory.com';
window['_fs_org'] = 'MP5K7';
window['_fs_namespace'] = 'FS';
(function(m,n,e,t,l,o,g,y){
    if (e in m) {if(m.console && m.console.log) { m.console.log('FullStory namespace conflict. Please set window["_fs_namespace"].');} return;}
    g=m[e]=function(a,b,s){g.q?g.q.push([a,b,s]):g._api(a,b,s);};g.q=[];
    o=n.createElement(t);o.async=1;o.crossOrigin='anonymous';o.src='https://'+_fs_host+'/s/fs.js';
    y=n.getElementsByTagName(t)[0];y.parentNode.insertBefore(o,y);
    g.identify=function(i,v,s){g(l,{uid:i},s);if(v)g(l,v,s)};g.setUserVars=function(v,s){g(l,v,s)};g.event=function(i,v,s){g('event',{n:i,p:v},s)};
    g.shutdown=function(){g("rec",!1)};g.restart=function(){g("rec",!0)};
    g.log = function(a,b) { g("log", [a,b]) };
    g.consent=function(a){g("consent",!arguments.length||a)};
    g.identifyAccount=function(i,v){o='account';v=v||{};v.acctId=i;g(o,v)};
    g.clearUserCookie=function(){};
})(window,document,window['_fs_namespace'],'script','user');
</script> <link href="/assets/stylesheets/highlightjs/a11y-light-3f5cde8e.css" rel=stylesheet /> </head> <body class="tao-microservice tao-microservice_chapter1 tao-microservice_chapter1_index typo"> <article> <h1 id=the-tao-of-microservices-->The Tao of Microservices 读书笔记 (一）</h1> <p>刚看到本书的书名，吓了一跳，不过看过才知道，虽然书名里有一个”道“，但是书中的实例还是非常丰富的。 这第一章上来就是一个用微服务构建一个简单微博的例子。</p> <p>先来看看在这个系统中会发生什么业务逻辑呢？</p> <ol> <li>创建一条微博</li> <li>列出之前的微博</li> </ol> <p>这些活动可以被一条条 message 来表示，比如 <code>post:entry</code>, 它的 json 数据格式是：</p> <p><code>js { post: 'entry', user: 'alice', text: 'Curiouser and curiouser!' } </code></p> <p>这样，任何对这条消息感兴趣的为服务都可以订阅 <code>post:entry</code> 消息来获取信息了。</p> <p>再来看看列出之前的微博的功能，我们使用 <code>store:list,kind:entry</code> 作为消息名称，它的格式是：</p> <p><code>js { store: 'list', kind: 'entry', user: 'alice' } </code></p> <p>以此类推，还可以有下面这些消息：</p> <ul> <li><code>store:list,kind:entry</code></li> <li><code>store:load,kind:entry</code></li> <li><code>store:save,kind:entry</code></li> <li><code>store:remove,kind:entry</code></li> </ul> <p>和储存有关的消息都可以用 <code>store</code> 作为前缀。</p> <p>有了消息之后，我们不难想象它们会在何时被传递：</p> <ul> <li> <p>当用户创建一条微博时，web server 就会发送一条 <code>post:entry</code> 消息，它会触发 <code>store:list,kind:entry</code> 消息。</p> </li> <li> <p>当用户列出他们之前的微博时，web server 会发出 <code>store:list,kind:entry</code> 消息来获取列表。</p> </li> </ul> <p>有另一个问题是，这些消息是<sub>异步</sub><sub>的还是</sub><sub>同步</sub><sub>的呢</sub>？ 一般来说，发送者想要获得反馈是使用同步，泛指异步。 比如：</p> <ul> <li><code>post:entry</code> 是同步的，因为用户想要收到微博被创建的确认信息。</li> <li><code>store:save,kind:entry</code> 也是同步的，原因同上</li> <li><code>store:list,kind:entry</code> 也是同步的，因为发出这条消息的目的就是为了获取微博的列表。</li> </ul> <p>那么有没有异步的消息呢？假设有一个 <code>info:entry</code> 消息，表示一个新的微博被创建了，它不需要有回复，它就是异步的。可能有别的微服务对它感兴趣，也可能没有。</p> <p>下面是业务活动和消息的关系表：</p> <table> <thead> <tr> <th>Actity</th> <th>Message flow</th> </tr> </thead> <tbody> <tr> <td>Post entry</td> <td>1. <code>post:entry</code></td> </tr> <tr> <td> </td> <td>2. <code>store:save, kind:entry</code></td> </tr> <tr> <td> </td> <td>3. <code>info:entry</code></td> </tr> <tr> <td>List entry</td> <td>4. <code>store:list,kind:entry</code></td> </tr> </tbody> </table> <p>这种先考虑消息的设计思路，可以让我们避免一开始就陷入实现的细节。</p> <p>下面我们可以考虑微服务的模块了：</p> <ul> <li><code>front</code> 处理 HTTP 请求的 web server</li> <li><code>entry-store</code> 处理微博数据的持久化</li> <li><code>post</code> 处理创建微博的消息的流向</li> </ul> <p>每个模块都有发送和接收的消息：</p> <table> <thead> <tr> <th>Microservices</th> <th>Sends</th> <th>Reveives</th> </tr> </thead> <tbody> <tr> <td>front</td> <td><code>post:entry</code></td> <td> </td> </tr> <tr> <td> </td> <td><code>store:list,kind:entry</code></td> <td> </td> </tr> <tr> <td>entry-store</td> <td> </td> <td><code>store:list,kind:entry</code></td> </tr> <tr> <td> </td> <td> </td> <td><code>store:save,kind:entry</code></td> </tr> <tr> <td>post</td> <td><code>store:save,kind:entry</code></td> <td><code>post:entry</code></td> </tr> <tr> <td> </td> <td><code>info:entry</code></td> <td> </td> </tr> </tbody> </table> <p>应用现在的功能很简单，下面我们来第一次迭代，加入搜索功能：</p> <p>对于搜索，我们可以想到两个消息：</p> <ul> <li><code>search:insert</code></li> <li><code>search:query</code></li> </ul> <p>下面需要考虑的是这个新的微服务（叫它 <code>index</code> 吧），怎么和之前的服务交互。</p> <p><code>front</code> 服务可以发送 <code>search:query</code> 消息来获取符合搜索的结果，这个 OK, 但是如果让 <code>post</code> 服务发送 <code>search:insert</code> 消息就不 OK 了，已经有一个 <code>info:entry</code> 消息了，我们可以让 <code>index</code> 服务去监听 <code>info:entry</code> 消息，这样就可以实现解耦了。</p> <p>等等，这样还是不对， <code>index</code> 作为一个搜索服务，不应该知道 <code>post</code> 服务会发送的 <code>info:entry</code> 消息，我们应该把这些消息的发送与接收做成 runtime 的配置，这样才能做到服务间的解耦。</p> <table> <thead> <tr> <th>Microservices</th> <th>Sends</th> <th>Reveives</th> </tr> </thead> <tbody> <tr> <td>front</td> <td><code>post:entry</code></td> <td> </td> </tr> <tr> <td> </td> <td><code>store:list,kind:entry</code></td> <td> </td> </tr> <tr> <td> </td> <td><code>search:list</code></td> <td> </td> </tr> <tr> <td>entry-store</td> <td> </td> <td><code>store:list,kind:entry</code></td> </tr> <tr> <td> </td> <td> </td> <td><code>store:save,kind:entry</code></td> </tr> <tr> <td>post</td> <td><code>store:save,kind:entry</code></td> <td><code>post:entry</code></td> </tr> <tr> <td> </td> <td><code>info:entry</code></td> <td> </td> </tr> <tr> <td>index</td> <td> </td> <td><code>search:query</code></td> </tr> <tr> <td> </td> <td> </td> <td><code>search:insert</code></td> </tr> <tr> <td> </td> <td> </td> <td><code>info:entry</code></td> </tr> </tbody> </table> <p>让我们把这个新的迭代部署上生产环境吧。 首先部署 <code>index</code> 服务，它不影响现有的服务，只会监听 <code>info:entry</code> 消息，并建立索引。 之后要修改 <code>front</code> 服务，让它支持 <code>search:query</code> 消息，这里使用蓝绿部署，先让两个版本的 <code>front</code> 服务共存，确认没问题后再关闭所有的旧版本实例。</p> <p>好了，我们给应用添加了搜索功能，下一个迭代是添加缓存服务。</p> <p>要添加缓存，如果是一个一体化应用的话，就要重新部署整个项目了，不过微服务的话，只需要添加一个 <code>entry-cache</code> 服务。</p> <p>这个服务会监听 <code>store:*,kind:entry</code> 消息，只要是和 <code>store</code> 有关的 <code>entry</code>, 它都会去处理。</p> <p>比如： <code>entry-cahce</code> 接收到 <code>store:list,kind:entry</code> , 它会先看看缓存中是否存在这个用户的数据，如果有就直接返回，如果没有就发送 <code>store:list,kined:entry,cache:true</code> 消息，而 <code>entry-store</code> 服务会接收这个消息，并返回微博的列表给 <code>entry-cache</code> 服务。</p> <p>要部署这个新服务稍微有点复杂，首先要升级部分 <code>entry-store</code>, 让它可以接收 <code>store:*</code> 和 <code>store:*,cache:true</code> 消息（为了 <code>store-cache</code> 作准备），接着关闭所有旧版本的 <code>entry-store</code> 实例， 再添加新的 <code>entry-cache</code> 服务，之后再升级 <code>entry-store</code> 服务让它只接收 <code>store:*,cache:true</code> 消息，最后关闭可以同时接收包含与不包含 <code>cache:true</code> 消息的中间版本 <code>entry-store</code> .</p> <p>通过这种添加和移除微服务的操作，我们可以把风险降低，如果任何一步出现错误，我们可以很容易的回滚。</p> <p>下一个迭代要添加的功能是 TimeLines.</p> <p>微博中，关注用户是一个非常重要的功能，我们可以对 TimeLines 相关的功能建立下面这些消息：</p> <ul> <li>follow:user</li> <li>follow:list,kind:followers</li> <li>follow:list,kind:following</li> <li>timeline:insert</li> <li>timeline:list</li> </ul> <p>根据消息我们不难发现需要新建两个微服务 <code>follow</code> 和 <code>timeline</code> . 现在有个问题，就是 <code>timeline</code> 服务应该是主动生成数据，还是被动的被调用呢？ 如果是被动的形式，那么当获取一个用户的 timeline 时，需要先获取用户关注的对象列表，然后再去获取这些被关注对象的 entry 来生成 timeline, 这样太复杂了，也不容易被缓存。 而使用主动的形式的话，可以让 <code>timeline</code> 服务监听 <code>info:entry</code> 消息，每当一条微博被发布时，获取作者的粉丝，然后对每个粉丝，把这条微博插入他们的 timeline 中，虽然这样做会有数据冗余，但是这样可扩展性更强，何况硬件很便宜。</p> <p>不过按照这种方式的话，需要引入另一个微服务来监听 <code>info:entry</code> 消息，然后发送 <code>follow:list,kind:followers</code> 消息来获取粉丝列表， 然后再发送 <code>timeline:insert</code> 来插入 timeline, 我们就来叫它 <code>fanout</code> 服务吧。</p> <p>另外，微服务的数据都是自治的，所以每个微服务可以有自己的数据源，所以我们可以用关系型数据储存微博信息, 用 key-value 数据库储存关注关系，全文搜索引擎用于搜索。</p> <p>最后我们来看看应用的 Scaling.</p> <p>假设我们的数据越来越多，特别时 Timelines 的设计让冗余数据很多，数据库操作越来越慢，我们可以选择数据库的分片，比如按照用户名首字母分成 26 个片，但是这样的操作依赖的时特定的数据库技术，我们想要的是从微服务的角度来解决这个问题。</p> <p>我们可以创建 26 个新的 Timelines 服务，每个都监听一个英文字母开头的消息，这个并不难，难的地方是部署，可以参考之前的缓存服务的部署方式：</p> <ul> <li>启动 <code>timeline-shared</code> 服务</li> <li>原来的 <code>timeline</code> 服务在接收到 <code>post:entry</code> 消息后发送 <code>timeline:*,shared:*</code> 消息</li> <li>每个 <code>timeline-shared</code> 接收自己感兴趣的消息，同时 <code>timeline</code> 服务也要迁移旧的数据到新的 <code>timeLine-shared</code> 服务的数据源中</li> <li>一切部署好后，去掉 <code>timeline</code> 自己的数据储存功能</li> </ul> <p>最后总结一下，一个微服务系统可以被这样理解：</p> <ul> <li>列出消息，它们定义了业务活动</li> <li>列出各个服务所发送和接收的消息</li> </ul> <h3 id=section>核心技术原则</h3> <h4 id=section-1>传输独立性</h4> <p>微服务之前的消息传递，不应该知道对方的存在，如果一个微服务要知道另一个微服务的存在和它的消息协议才能发送消息的话，那是一种失败。</p> <h4 id=section-2>模式匹配</h4> <p>模式匹配是一种能力，可以基于消息的数据进行路由。有了这种能力，就可以在不影响原有服务的情况下，添加或移除处理特殊情况的微服务（比如上文的 <code>cache:true</code> 的消息）。</p> <h4 id=section-3>可添加性</h4> <p>就像 SOLID 原则中的开闭原则一样，可添加性让应用的修改更加容易，避免之前的技术债。上面提到的传输独立性和模式匹配都是实现可添加性的基石。</p> </article> <script src="/assets/javascripts/all-70879c36.js"></script> <script src="/assets/javascripts/highlight-e7667caa.js"></script> <script>hljs.initHighlightingOnLoad()</script> <div id=github-comments></div> <script src="/assets/javascripts/comment-ddc93c2f.js" id=github-comment data-ssl=true data-theme=green data-username=teddy-ma data-repo="teddy-ma.github.io" data-page-id="tao-microservice/chapter1.html"></script> </body> </html>